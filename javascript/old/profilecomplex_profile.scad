// Generated by dxf_to_scad_profile.js
// Source file: profilecomplex.dxf
// Profile name: profilecomplex
// Profile points (half): 44
// Profile bounds: X[0.0000, 4.0000] Y[0.0000, 4.4172]
// NOTE: DXF should contain only the RIGHT HALF of the profile (x >= 0)
//       The full profile is created by mirroring.

include <BOSL2/std.scad>

// Half profile from DXF (x-positive side, right half)
// This is the base profile - all other profiles are derived from this
// Useful for rotate_extrude which requires x >= 0
function profilecomplex_xpositive(scalefactor=1) = [
    [0.000000 * scalefactor, -2.208617 * scalefactor],
    [0.000000 * scalefactor, 2.208617 * scalefactor],
    [0.064567 * scalefactor, 2.155723 * scalefactor],
    [0.127023 * scalefactor, 2.100350 * scalefactor],
    [0.187272 * scalefactor, 2.042585 * scalefactor],
    [0.245222 * scalefactor, 1.982514 * scalefactor],
    [0.300785 * scalefactor, 1.920228 * scalefactor],
    [0.353878 * scalefactor, 1.855824 * scalefactor],
    [0.404419 * scalefactor, 1.789398 * scalefactor],
    [0.452330 * scalefactor, 1.721051 * scalefactor],
    [0.497541 * scalefactor, 1.650888 * scalefactor],
    [0.539980 * scalefactor, 1.579016 * scalefactor],
    [0.579585 * scalefactor, 1.505543 * scalefactor],
    [0.616294 * scalefactor, 1.430582 * scalefactor],
    [0.650053 * scalefactor, 1.354246 * scalefactor],
    [0.680809 * scalefactor, 1.276652 * scalefactor],
    [0.708515 * scalefactor, 1.197918 * scalefactor],
    [0.733130 * scalefactor, 1.118163 * scalefactor],
    [0.754617 * scalefactor, 1.037508 * scalefactor],
    [0.772942 * scalefactor, 0.956078 * scalefactor],
    [0.788077 * scalefactor, 0.873994 * scalefactor],
    [0.800000 * scalefactor, 0.791383 * scalefactor],
    [2.200000 * scalefactor, 0.791383 * scalefactor],
    [2.205549 * scalefactor, 0.650156 * scalefactor],
    [2.222161 * scalefactor, 0.509801 * scalefactor],
    [2.249734 * scalefactor, 0.371181 * scalefactor],
    [2.288098 * scalefactor, 0.235152 * scalefactor],
    [2.337017 * scalefactor, 0.102553 * scalefactor],
    [2.396188 * scalefactor, -0.025800 * scalefactor],
    [2.465248 * scalefactor, -0.149115 * scalefactor],
    [2.543769 * scalefactor, -0.266631 * scalefactor],
    [2.631269 * scalefactor, -0.377624 * scalefactor],
    [2.727208 * scalefactor, -0.481409 * scalefactor],
    [2.830994 * scalefactor, -0.577348 * scalefactor],
    [2.941987 * scalefactor, -0.664848 * scalefactor],
    [3.059503 * scalefactor, -0.743369 * scalefactor],
    [3.182817 * scalefactor, -0.812429 * scalefactor],
    [3.311170 * scalefactor, -0.871600 * scalefactor],
    [3.443769 * scalefactor, -0.920519 * scalefactor],
    [3.579798 * scalefactor, -0.958883 * scalefactor],
    [3.718418 * scalefactor, -0.986456 * scalefactor],
    [3.858774 * scalefactor, -1.003068 * scalefactor],
    [4.000000 * scalefactor, -1.008617 * scalefactor],
    [4.000000 * scalefactor, -2.208617 * scalefactor]
];

// Full symmetric profile (mirrored from xpositive)
// Created by taking xpositive points and adding mirrored (x-negative) points
function profilecomplex_mirroredx(scalefactor=1) =
    let(half = profilecomplex_xpositive(scalefactor))
    let(mirrored = [for (i = [len(half)-1 : -1 : 0]) [-half[i].x, half[i].y]])
    concat(half, mirrored);

// Full profile rotated 90 degrees clockwise around Z axis
// Original (x, y) becomes (y, -x)
function profilecomplex_mirroredx_rotatedz(scalefactor=1) =
    let(full = profilecomplex_mirroredx(scalefactor))
    [for (p = full) [p.y, -p.x]];

// Profile prepared for rotate_extrude around X axis (workaround)
// The full mirrored profile is used, then:
// Step 1: Rotate 90° clockwise around Z: (x, y) → (y, -x)
// Step 2: Shift so all x >= 0 (required for rotate_extrude)
// Result: ready for rotate_extrude, then rotate result back -90° around Z
function profilecomplex_for_revolve_around_x(scalefactor=1) =
    let(full = profilecomplex_mirroredx(scalefactor))
    let(rotated = [for (p = full) [p.y, -p.x]])           // rotate 90° CW around Z
    let(min_x = min([for (p = rotated) p.x]))             // find minimum x
    let(shifted = [for (p = rotated) [p.x - min_x, p.y]]) // shift so all x >= 0
    shifted;

// Module to revolve the profile around the X axis
// Uses rotate_extrude (which revolves around Z) with coordinate transformation
// angle: revolution angle in degrees (default 90)
module profilecomplex_revolve_around_x(scalefactor=1, angle=90) {
    // Calculate the shift amount to undo it after extrusion
    full = profilecomplex_mirroredx(scalefactor);
    rotated = [for (p = full) [p.y, -p.x]];
    min_x = min([for (p = rotated) p.x]);

    // Rotate back -90° around Z and translate to compensate for the shift
    rotate([0, 0, -90])
    translate([min_x, 0, 0])
    rotate_extrude(angle=angle, convexity=10)
    polygon(profilecomplex_for_revolve_around_x(scalefactor));
}

// ===== PROFILE BOUNDING BOX =====
// Calculated from the half profile, used for spacing test parts
profilecomplex_width = 4.000000;   // X extent of half profile
profilecomplex_height = 4.417234;  // Y extent of profile

// Full profile dimensions (mirrored)
profilecomplex_full_width = profilecomplex_width * 2;
profilecomplex_full_height = profilecomplex_height;

// Spacing with margin (2x profile dimensions for comfortable viewing)
spacing_y = profilecomplex_full_height * 2 + 10;
spacing_x = profilecomplex_full_width * 2 + 10;

// ===== TEST SECTION =====
// Render quality
$fn = 30;

// Test path - a simple straight line
test_length = 100;
test_line = [[0, 0, 0], [test_length, 0, 0]];

// Test with different profiles
color("red")
path_sweep(profilecomplex_mirroredx(1), test_line);

translate([0, spacing_y, 0])
color("green")
path_sweep(profilecomplex_xpositive(1), test_line);

translate([0, spacing_y * 2, 0])
color("blue")
path_sweep(profilecomplex_mirroredx_rotatedz(1), test_line);

// Test revolve around X axis (90 degree turn)
translate([0, spacing_y * 3, 0])
color("purple")
profilecomplex_revolve_around_x(1, 90);

// Show the 2D profiles for reference
translate([test_length + 20, 0, 0]) {
    color("red", 0.5)
    linear_extrude(1)
    polygon(profilecomplex_mirroredx(1));

    translate([0, spacing_y, 0])
    color("green", 0.5)
    linear_extrude(1)
    polygon(profilecomplex_xpositive(1));

    translate([0, spacing_y * 2, 0])
    color("blue", 0.5)
    linear_extrude(1)
    polygon(profilecomplex_mirroredx_rotatedz(1));
}
