// Generated by dxf_to_scad_with_joints_non_tangent_only.js
// Source file: tangent_arcs.dxf
// Non-tangent junctions found: 1

include <BOSL2/std.scad>

// ===== CONFIGURATION =====
SECANT_THRESHOLD = 30;  // Angle difference (degrees) requiring blending
OVERLAP_FACTOR = 2.0;   // Extension overlap multiplier (1.5-3.0)
ARC_SUBDIVISIONS = 30;  // Points per arc

// Render quality
$fn = 30;

// ===== POINT DEFINITIONS =====


// ===== LINE DEFINITIONS =====


// ===== ARC DEFINITIONS =====
arc0 = [
    [31.593796, 0.000000, 0],  // center
    13.747147,  // radius
    94.677095,  // start angle (degrees)
    180.000000  // end angle (degrees)
];
arc1 = [
    [0.000000, 0.000000, 0],  // center
    17.846649,  // radius
    0.000000,  // start angle (degrees)
    74.506993  // end angle (degrees)
];

// ===== CIRCLE DEFINITIONS =====


// ===== HELPER FUNCTIONS =====

// Auto-detect maximum extent of profile from center
function profile_max_extent(prof) =
    max([for (p = prof) max(abs(p.x), abs(p.y))]);

// Calculate extension angle based on profile width and arc radius
function calc_extension_angle(radius, profile_hw, overlap=OVERLAP_FACTOR) =
    atan2(profile_hw * overlap, radius);

// Calculate extension length for lines based on profile width
function calc_extension_length(profile_hw, overlap=OVERLAP_FACTOR) =
    profile_hw * overlap;

// Generate arc path with optional extension
function make_arc_path(arc_def, extend_start=0, extend_end=0, n=ARC_SUBDIVISIONS) =
    let(
        center = arc_def[0],
        radius = arc_def[1],
        start_a = arc_def[2],
        end_a = arc_def[3]
    )
    [for (p = arc(r=radius, angle=[start_a - extend_start, end_a + extend_end], n=n))
        [p.x + center.x, p.y + center.y, 0]];

// Generate line path with optional extension
function make_line_path(line_def, extend_start=0, extend_end=0) =
    let(
        p1 = line_def[0],
        p2 = line_def[1],
        dx = p2.x - p1.x,
        dy = p2.y - p1.y,
        len = norm([dx, dy]),
        ux = dx / len,
        uy = dy / len,
        new_p1 = [p1.x - ux * extend_start, p1.y - uy * extend_start, p1.z],
        new_p2 = [p2.x + ux * extend_end, p2.y + uy * extend_end, p2.z]
    )
    [new_p1, new_p2];

// ===== SWEEP MODULES =====

// Sweep a line with a profile
module sweep_line(profile, line_def) {
    path_sweep(profile, line_def);
}

// Sweep an arc with a profile
module sweep_arc(profile, arc_def, n_segments=ARC_SUBDIVISIONS) {
    center = arc_def[0];
    radius = arc_def[1];
    start_angle = arc_def[2];
    end_angle = arc_def[3];

    translate(center)
    path_sweep(profile, arc(n=n_segments, r=radius, angle=[start_angle, end_angle]));
}

// Sweep a circle with a profile
module sweep_circle(profile, circle_def, n_segments=50) {
    center = circle_def[0];
    radius = circle_def[1];
    circle_path = path3d(circle(r=radius, $fn=n_segments));

    translate(center)
    path_sweep(profile, circle_path, closed=true);
}

// ===== JUNCTION BLENDING MODULES =====

// Blend junction between two lines
module blend_junction_line_line(profile, line_a, line_b, extend_a, extend_b) {
    prof_hw = profile_max_extent(profile);
    ext = calc_extension_length(prof_hw);

    // Create extended paths based on which end to extend
    path_a = extend_a == "start"
        ? make_line_path(line_a, extend_start=ext)
        : make_line_path(line_a, extend_end=ext);
    path_b = extend_b == "start"
        ? make_line_path(line_b, extend_start=ext)
        : make_line_path(line_b, extend_end=ext);

    intersection() {
        path_sweep(profile, path_a);
        path_sweep(profile, path_b);
    }
}

// Blend junction between line and arc
module blend_junction_line_arc(profile, line_def, arc_def, extend_line, extend_arc) {
    prof_hw = profile_max_extent(profile);
    ext_line = calc_extension_length(prof_hw);
    ext_arc = calc_extension_angle(arc_def[1], prof_hw);

    // Create extended line path
    path_line = extend_line == "start"
        ? make_line_path(line_def, extend_start=ext_line)
        : make_line_path(line_def, extend_end=ext_line);

    // Create extended arc path
    path_arc = extend_arc == "start"
        ? make_arc_path(arc_def, extend_start=ext_arc)
        : make_arc_path(arc_def, extend_end=ext_arc);

    intersection() {
        path_sweep(profile, path_line);
        path_sweep(profile, path_arc);
    }
}

// Blend junction between arc and line (wrapper for consistency)
module blend_junction_arc_line(profile, arc_def, line_def, extend_arc, extend_line) {
    blend_junction_line_arc(profile, line_def, arc_def, extend_line, extend_arc);
}

// Blend junction between two arcs
module blend_junction_arc_arc(profile, arc_a, arc_b, extend_a, extend_b) {
    prof_hw = profile_max_extent(profile);
    ext_a = calc_extension_angle(arc_a[1], prof_hw);
    ext_b = calc_extension_angle(arc_b[1], prof_hw);

    // Create extended arc paths
    path_a = extend_a == "start"
        ? make_arc_path(arc_a, extend_start=ext_a)
        : make_arc_path(arc_a, extend_end=ext_a);
    path_b = extend_b == "start"
        ? make_arc_path(arc_b, extend_start=ext_b)
        : make_arc_path(arc_b, extend_end=ext_b);

    intersection() {
        path_sweep(profile, path_a);
        path_sweep(profile, path_b);
    }
}

// ===== FINAL PART =====

// Sweeps all entities and adds junction blending for non-tangent meets
module final_part(profile) {
    union() {
        // Sweep lines


        // Sweep arcs
        sweep_arc(profile, arc0);
        sweep_arc(profile, arc1);

        // Sweep circles
        // (no circles)

        // Junction blending for non-tangent meets
        // Junction 0: arc0 meets arc1
        blend_junction_arc_arc(profile, arc0, arc1, "end", "start");
    }
}

// ===== EXAMPLE PROFILE =====

// Simple rectangular profile
function rect_profile(w=3, h=2) = [
    [-w/2, 0],
    [w/2, 0],
    [w/2, h],
    [-w/2, h]
];

// Diamond profile (good for 3D printing)
function diamond_profile(size=3) = [
    [-size, 0],
    [0, size],
    [size, 0],
    [0, -size]
];

// ===== USAGE =====

final_part(rect_profile(3, 2));
